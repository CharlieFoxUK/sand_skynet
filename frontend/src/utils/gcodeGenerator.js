/**
 * Shared G-code Generator Utility
 * 
 * Generates G-code from drawing paths for all canvas pages.
 * Uses coordinateTransform for consistent coordinate mapping.
 * 
 * All generated G-code includes the PRE-TRANSFORMED header to tell
 * the server to skip any additional orientation transforms.
 */

import { canvasToGcode, centerNormalizedToGcode } from './coordinateTransform';

/**
 * Coordinate types for different canvas sources
 */
export const CoordinateType = {
    CANVAS: 'canvas',           // Raw canvas pixels (Canvas, EtchASketch)
    CENTER_NORMALIZED: 'centerNormalized', // -1 to 1 centered (Kaleidoscope, Spirograph)
    PATTERN_BUILDER: 'patternBuilder'      // -1 to 1 centered (PatternBuilder layers)
};

/**
 * Generate G-code from paths
 * @param {Array} paths - Array of path arrays, each path is [{x, y}, ...]
 * @param {Object} config - Table config from getTableConfig()
 * @param {Object} options - Generation options
 * @param {number} options.feedrate - Feed rate for G1 moves (default: 2000)
 * @param {string} options.coordinateType - One of CoordinateType values
 * @param {Object} options.canvasSize - {width, height} required for CANVAS type
 * @returns {string} G-code string
 */
export function generateGCode(paths, config, options = {}) {
    const {
        feedrate = 2000,
        coordinateType = CoordinateType.CANVAS,
        canvasSize = { width: 1, height: 1 }
    } = options;

    // Select transform function based on coordinate type
    let transform;
    switch (coordinateType) {
        case CoordinateType.CENTER_NORMALIZED:
        case CoordinateType.PATTERN_BUILDER:
            transform = (x, y) => centerNormalizedToGcode(x, y, config);
            break;
        case CoordinateType.CANVAS:
        default:
            transform = (x, y) => canvasToGcode(x, y, canvasSize.width, canvasSize.height, config);
            break;
    }

    let gcode = "";
    let firstMove = true;
    let firstCut = true;

    for (const path of paths) {
        if (!path || path.length === 0) continue;

        let needsRapidMove = true;

        for (let i = 0; i < path.length; i++) {
            const point = path[i];

            // Handle stroke breaks (NaN coordinates or isBreak flag)
            if (point.isBreak || isNaN(point.x) || isNaN(point.y)) {
                needsRapidMove = true;
                continue;
            }

            const gp = transform(point.x, point.y);

            // Validate transformed coordinates
            if (isNaN(gp.x) || isNaN(gp.y)) {
                console.error("NaN coordinates after transform:", point, "->", gp);
                continue;
            }

            if (needsRapidMove) {
                // G0 = rapid move (travel without drawing)
                gcode += `G0 X${gp.x.toFixed(3)} Y${gp.y.toFixed(3)}`;
                if (firstMove) {
                    gcode += " ; TYPE: PRE-TRANSFORMED";
                    firstMove = false;
                }
                gcode += "\n";
                needsRapidMove = false;
            } else {
                // G1 = linear interpolation (drawing move)
                gcode += `G1 X${gp.x.toFixed(3)} Y${gp.y.toFixed(3)}`;
                if (firstCut) {
                    gcode += ` F${feedrate}`;
                    firstCut = false;
                }
                gcode += "\n";
            }
        }
    }

    return gcode;
}

/**
 * Generate G-code header comments
 * @param {string} drawingType - Type of drawing (canvas, etch-a-sketch, etc.)
 * @param {Object} config - Table config
 * @returns {string} Header comments
 */
export function generateGCodeHeader(drawingType, config) {
    const { drawWidth, drawHeight, offsetX, offsetY } = config;
    return [
        `; Drawing Type: ${drawingType}`,
        `; Generated by Sand Table`,
        `; Drawing bounds: X${offsetX}-${offsetX + drawWidth} Y${offsetY}-${offsetY + drawHeight}`,
        '; TYPE: PRE-TRANSFORMED',
        ''
    ].join('\n');
}

/**
 * Upload G-code to the sand table server
 * @param {string} gcode - G-code string
 * @param {string} name - Drawing name
 * @returns {Promise} Upload result
 */
export async function uploadGCode(gcode, name) {
    const blob = new Blob([gcode], { type: 'text/plain' });

    let filename = (name || '').trim();
    if (filename === "") {
        filename = `drawing_${Date.now()}`;
    }
    if (!filename.toLowerCase().endsWith(".gcode")) {
        filename += ".gcode";
    }

    const formData = new FormData();
    formData.append('file', blob, filename);
    formData.append('filename', filename);

    const response = await fetch('/api/upload/', {
        method: 'POST',
        body: formData
    });

    if (response.ok) {
        return response.json();
    } else {
        const text = await response.text();
        throw new Error(`Upload failed: ${response.status} ${text}`);
    }
}

/**
 * Download G-code as a file
 * @param {string} gcode - G-code string
 * @param {string} name - Filename
 */
export function downloadGCode(gcode, name) {
    const blob = new Blob([gcode], { type: 'text/plain' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');

    let filename = (name || '').trim();
    if (filename === "") {
        filename = `drawing_${Date.now()}`;
    }
    if (!filename.toLowerCase().endsWith(".gcode")) {
        filename += ".gcode";
    }

    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
}
